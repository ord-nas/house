<!DOCTYPE html>
<html>
    <head>
        <script type="text/javascript">
         const global_image_urls = {
             steve: "imgs/people/steve/Steve Head.png",
             david: "imgs/people/david/David Head.png",
             carlos: "imgs/people/carlos/Carlos Head.png",
             sandro: "imgs/people/sandro/Sandro Head.png",
             house: "imgs/house.png",
             table: "imgs/table.png",
         };

         const global_motion_graph = {
             nodes: {
                 "living_chair_1": [243, 1035],
                 "living_chair_2": [307, 1035],
                 "living_chair_3": [510, 1035],
                 "kitchen_chair_1": [675, 1035],
                 "kitchen_chair_2": [725, 1035],
                 "kitchen_chair_3": [777, 1035],
                 "kitchen_chair_4": [827, 1035],
                 "kitchen_cooking": [1000, 1035],
                 "stairs_1_bottom": [1300, 1035],
                 "stairs_1_top": [1535, 763],
                 "stairs_2_bottom": [1300, 763],
                 "stairs_2_top": [1535, 490],
                 "desk_1": [242, 763],
                 "desk_2": [433, 763],
                 "bed_1": [685, 763], // Maybe adjust
                 "bed_2": [740, 763], // Maybe adjust
                 "tv_chair_1": [993, 763],
                 "tv_chair_2": [1055, 763],
                 "bathroom_1": [210, 490],
                 "bathroom_2": [283, 490],
                 "bathroom_3": [356, 490],
                 "bathroom_4": [430, 490],
                 "gym": [778, 490],
             },
             edges: [
                 ["living_chair_1", "living_chair_2"],
                 ["living_chair_2", "living_chair_3"],
                 ["living_chair_3", "kitchen_chair_1"],
                 ["kitchen_chair_1", "kitchen_chair_2"],
                 ["kitchen_chair_2", "kitchen_chair_3"],
                 ["kitchen_chair_3", "kitchen_chair_4"],
                 ["kitchen_chair_4", "kitchen_cooking"],
                 ["kitchen_cooking", "stairs_1_bottom"],
                 ["stairs_1_bottom", "stairs_1_top"],
                 ["stairs_1_top", "stairs_2_bottom"],
                 ["stairs_2_bottom", "stairs_2_top"],
                 ["stairs_2_bottom", "tv_chair_2"],
                 ["tv_chair_2", "tv_chair_1"],
                 ["tv_chair_1", "bed_2"],
                 ["bed_2", "bed_1"],
                 ["bed_1", "desk_2"],
                 ["desk_2", "desk_1"],
                 ["stairs_2_top", "gym"],
                 ["gym", "bathroom_4"],
                 ["bathroom_4", "bathroom_3"],
                 ["bathroom_3", "bathroom_2"],
                 ["bathroom_2", "bathroom_1"],
             ],
             targets: [
                 "living_chair_1",
                 "living_chair_2",
                 "living_chair_3",
                 "kitchen_chair_1",
                 "kitchen_chair_2",
                 "kitchen_chair_3",
                 "kitchen_chair_4",
                 "kitchen_cooking",
                 "desk_1",
                 "desk_2",
                 "tv_chair_1",
                 "tv_chair_2",
                 "gym",
             ],
         };

         function get_graph_neighbors() {
             var neighbors = {};
             for (var [n1, n2] of global_motion_graph.edges) {
                 if (!neighbors.hasOwnProperty(n1)) neighbors[n1] = [];
                 if (!neighbors.hasOwnProperty(n2)) neighbors[n2] = [];
                 neighbors[n1].push(n2);
                 neighbors[n2].push(n1);
             }
             return neighbors;
         }

         function get_path(start_node, end_node) {
             // Get neighbors of each node.
             const neighbors = get_graph_neighbors();

             // DFS the graph from start_node.
             var backtrace = {[start_node]: null};
             var queue = [start_node];
             while (queue.length > 0) {
                 const current = queue.shift();
                 for (const next of neighbors[current]) {
                     if (backtrace.hasOwnProperty(next)) continue;
                     backtrace[next] = current;
                     queue.push(next);
                 }
             }

             // Construct the path by following backtraces from end_node.
             var path = [];
             var node = end_node;
             while (node !== null && node !== undefined) {
                 path.push(node);
                 node = backtrace[node];
             }
             path.reverse();
             return path;
         }

         function lerp(a, b, t) {
             return a + (b - a) * t;
         }

         // Returns {p: [x, y], finished: bool}.
         function get_point_along_path(path, pixels) {
             for (var i = 0; i < path.length - 1; i += 1) {
                 const [x1, y1] = global_motion_graph.nodes[path[i]];
                 const [x2, y2] = global_motion_graph.nodes[path[i+1]];
                 const distance = Math.sqrt((x2 - x1)**2 + (y2 - y1)**2);
                 if (pixels <= distance) {
                     const frac = pixels / distance;
                     const x = lerp(x1, x2, frac);
                     const y = lerp(y1, y2, frac);
                     return {
                         p: [x, y],
                         finished: false,
                     };
                 }
                 pixels -= distance;
             }

             // If we get here, we've finished the path.
             return {
                 p: global_motion_graph.nodes[path[path.length-1]],
                 finished: true,
             };
         }

         function make_person(head_image, arm_color, body_color, bounce_period, arm_period) {
             return {
                 params: {
                     head_image: head_image,
                     scale: 0.25,
                     arm_color: arm_color,
                     body_color: body_color,
                     bounce: {
                         offset_ms: 0,
                         period_ms: bounce_period,
                     },
                     arm: {
                         offset_ms: 0,
                         period_ms: arm_period,
                     },
                     walking_speed_pps: 150,
                 },
                 animation: null,
                 next_action_time: null,
                 next_event: null,
             };
         }

         function get_image_promise([key, url]) {
             return new Promise((resolve, reject) => {
                 const image = new Image();
                 image.src = url;
                 image.onload = () => { resolve({[key]: image}); };
                 image.onerror = () => { reject("Failed to load: " + url); };
             });
         }

         // Returns a promise that resolves to a map of all the images once they are loaded.
         function load_images() {
             const promises = Object.entries(global_image_urls).map(get_image_promise);
             return Promise.all(promises).then((key_value_array) => {
                 // Convert key-value array to dictionary.
                 return Object.assign({}, ...key_value_array);
             });
         }

         function draw_arm(ctx, color, shoulder_x, shoulder_y, radius, length, rotation) {
             ctx.save();
             ctx.fillStyle = color;

             ctx.translate(shoulder_x, shoulder_y);
             ctx.rotate(rotation);

             ctx.beginPath();
             ctx.arc(0, 0, radius, 0, 2 * Math.PI);
             ctx.fill();

             ctx.beginPath();
             ctx.arc(0, length, radius, 0, 2 * Math.PI);
             ctx.fill();

             ctx.fillRect(-radius, 0, 2 * radius, length);

             ctx.restore();
         }

         function eased(time_ms, period_ms) {
             const offset_ms = time_ms % period_ms;
             return 0.5 - Math.cos(offset_ms / period_ms * 2 * Math.PI) / 2.0;
         }

         function get_wave_params_cyclic(person, current_time) {
             return {
                 arm_t: eased(current_time + person.arm.offset_ms, person.arm.period_ms),
                 bounce_t: eased(current_time + person.bounce.offset_ms, person.bounce.period_ms),
             };
         }

         function can_start(current_time, animation_start_time, p) {
             const start_offset = (animation_start_time + p.offset_ms) % p.period_ms;
             const till_end = p.period_ms - start_offset;
             const elapsed = current_time - animation_start_time;
             return elapsed > till_end;
         }

         function can_stop(current_time, animation_start_time, p) {
             const start_iter = Math.floor((animation_start_time + p.offset_ms) / p.period_ms);
             const current_iter = Math.floor((current_time + p.offset_ms) / p.period_ms);
             return current_iter > start_iter;
         }

         function get_wave_params_from_rest(person, current_time, animation_start_time) {
             const can_start_arms = can_start(current_time, animation_start_time, person.arm);
             const can_start_bounce = can_start(current_time, animation_start_time, person.bounce);
             return {
                 arm_t: can_start_arms ?
                        eased(current_time + person.arm.offset_ms, person.arm.period_ms) :
                        0.0,
                 bounce_t: can_start_bounce ?
                           eased(current_time + person.bounce.offset_ms, person.bounce.period_ms) :
                           0.0,
                 done: can_start_arms && can_start_bounce,
             };
         }

         function get_wave_params_to_rest(person, current_time, animation_start_time) {
             const can_stop_arms = can_stop(current_time, animation_start_time, person.arm);
             const can_stop_bounce = can_stop(current_time, animation_start_time, person.bounce);
             return {
                 arm_t: can_stop_arms ?
                        0.0 :
                        eased(current_time + person.arm.offset_ms, person.arm.period_ms),
                 bounce_t: can_stop_bounce ?
                           0.0 :
                           eased(current_time + person.bounce.offset_ms, person.bounce.period_ms),
                 done: can_stop_arms && can_stop_bounce,
             };
         }

         function draw_from_params(params) {
             var canvas = document.getElementById("c");
             var ctx = canvas.getContext("2d");
             ctx.resetTransform();

             const bounce_amount = params.bounce_t * 20;

             const top = 320 + bounce_amount;
             const bottom = 320 + 200;
             const left = 70;

             ctx.scale(params.scale, params.scale);
             ctx.translate(-(50 + left + 170/2), -bottom);
             ctx.translate(params.x / params.scale, params.y / params.scale);

             ctx.fillStyle = params.body_color;
             ctx.fillRect(50 + left, top, 170, (bottom - top));

             ctx.beginPath();
             ctx.arc(50 + left + 170/2, top, 170/2, 0, 2 * Math.PI);
             ctx.fill();

             const arm_offset_x = 10;
             const arm_offset_y = -30;
             draw_arm(ctx, params.arm_color, 50 + left + arm_offset_x, top + arm_offset_y, 20, 100, 2.5 * params.arm_t);
             draw_arm(ctx, params.arm_color, 50 + left + 170 - arm_offset_x, top + arm_offset_y, 20, 100, -2.5 * params.arm_t);

             ctx.drawImage(params.head_image, 30 + left, bounce_amount);
             ctx.resetTransform();
         }

         // A person has the follow properties:
         //  * params
         //  * currently-active animation
         //  * time at which the next action should be chosen (can be null)
         //  * next event to participate in (can be null)


         // The API for an animation is:
         //  * it has a tick() method that draws and returns whether the animation is done.
         //  * it has a request_done() method.
         //  * it has a can_request_done() method that returns true or false.
         //  * it has a resouce_events() method that returns an ordered list of resource acquire and relinquish events.
         //  * it has a resouces() method that returns a list of all currently-held resources.

         class StartWavingAni {
             constructor(person_params, [x, y]) {
                 this.person_params = person_params;
                 this.x = x;
                 this.y = y;
                 this.start_time = null;
             }

             tick(current_time) {
                 console.log("start_waving_tick");
                 if (this.start_time === null) {
                     this.start_time = current_time;
                 }
                 var params = {
                     x: this.x,
                     y: this.y,
                 };
                 Object.assign(params, this.person_params);
                 Object.assign(params, get_wave_params_from_rest(this.person_params, current_time, this.start_time));
                 draw_from_params(params);
                 return params.done;
             }

             request_done() {}
         }

         class StopWavingAni {
             constructor(person_params, [x, y]) {
                 this.person_params = person_params;
                 this.x = x;
                 this.y = y;
                 this.start_time = null;
             }

             tick(current_time) {
                 if (this.start_time === null) {
                     this.start_time = current_time;
                 }
                 var params = {
                     x: this.x,
                     y: this.y,
                 };
                 Object.assign(params, this.person_params);
                 Object.assign(params, get_wave_params_to_rest(this.person_params, current_time, this.start_time));
                 draw_from_params(params);
                 return params.done;
             }

             request_done() {}
         }

         class ContinueWavingAni {
             constructor(person_params, [x, y]) {
                 this.person_params = person_params;
                 this.x = x;
                 this.y = y;
                 this.start_time = null;
                 this.done = false;
             }

             tick(current_time) {
                 if (this.start_time === null) {
                     this.start_time = current_time;
                 }
                 var params = {
                     x: this.x,
                     y: this.y,
                 };
                 Object.assign(params, this.person_params);
                 Object.assign(params, get_wave_params_cyclic(this.person_params, current_time, this.start_time));
                 draw_from_params(params);
                 return this.done;
             }

             request_done() {
                 this.done = true;
             }
         }

         class WalkAni {
             constructor(person_params, start_node, end_node) {
                 this.person_params = person_params;
                 this.start_node = start_node;
                 this.end_node = end_node;
                 this.path = get_path(start_node, end_node);
                 this.start_time = null;
                 this.done = false;
             }

             tick(current_time) {
                 if (this.start_time === null) {
                     this.start_time = current_time;
                 }
                 const pixels = (current_time - this.start_time) / 1000 * this.person_params.walking_speed_pps;
                 const path_point = get_point_along_path(this.path, pixels);
                 var params = {
                     x: path_point.p[0],
                     y: path_point.p[1],
                 };
                 Object.assign(params, this.person_params);
                 Object.assign(params, get_wave_params_cyclic(this.person_params, current_time, this.start_time));
                 draw_from_params(params);
                 return path_point.finished;
             }

             request_done() {}
         }

         class SequentialAni {
             constructor(sequence) {
                 this.sequence = sequence;
                 this.current = 0;
             }

             tick(current_time) {
                 if (this.current >= this.sequence.length) {
                     return true;
                 }
                 const next = this.sequence[this.current].tick(current_time);
                 if (next) {
                     this.current += 1;
                 }
                 return false;
             }

             request_done() {
                 this.sequence.map((a) => { a.request_done(); });
             }
         }

         var global_ani = null;
         var global_world = null;

         function start_ani() {
             if (global_world === null) return;
             console.log("start_ani");
             global_ani = new SequentialAni([
                 new StartWavingAni(global_world.people.steve.params, global_motion_graph.nodes.living_chair_2),
                 //new ContinueWavingAni(global_world.people.steve.params, global_motion_graph.nodes.living_chair_2),
                 new WalkAni(global_world.people.steve.params, "living_chair_2", "gym"),
                 new StopWavingAni(global_world.people.steve.params, global_motion_graph.nodes.gym),
             ]);
         }

         function stop_ani() {
             if (global_ani !== null) {
                 global_ani.request_done();
             }
         }

         function set_up_animation_loop(world) {
             global_world = world;
             function tick() {
                 const current_time = new Date().getTime();

                 // Clear.
                 var canvas = document.getElementById("c");
                 var ctx = canvas.getContext("2d");
                 ctx.resetTransform();
                 ctx.clearRect(0, 0, canvas.width, canvas.height);

                 // Draw house.
                 ctx.scale(0.25, 0.25);
                 ctx.translate(0, -500);
                 ctx.drawImage(world.images.house, 0, 0);

                 // Animate.
                 if (global_ani !== null) {
                     global_ani.tick(current_time);
                 }

                 // Draw table.
                 ctx.resetTransform();
                 ctx.scale(0.25, 0.25);
                 ctx.translate(0, -500);
                 ctx.drawImage(world.images.table, 0, 0);

                 window.requestAnimationFrame(tick);
             }
             window.requestAnimationFrame(tick);
         }

         function main() {
             load_images().then((images) => {
                 const world = {
                     images: images,
                     people: {
                         steve: make_person(
                             images.steve,
                             /*arm_color=*/"blue",
                             /*body_color=*/"green",
                             /*bounce_period=*/900,
                             /*arm_period=*/2200
                         ),
                     },
                     animation_start_time: new Date().getTime(),
                 };
                 set_up_animation_loop(world);
                 start_ani();
             });
         }

         window.onload = main;
         console.log("test");
        </script>
    </head>
    <body>
        <canvas id="c" width="2300px" height="1100px"> </canvas>
        <button onclick="start_ani()">Start</button>
        <button onclick="stop_ani()">Stop</button>
    </body>
</html>
