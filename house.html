<!DOCTYPE html>
<html>
    <head>
        <script type="text/javascript">
         const global_image_urls = {
             steve: "imgs/people/steve/Steve Head.png",
             david: "imgs/people/david/David Head.png",
             carlos: "imgs/people/carlos/Carlos Head.png",
             sandro: "imgs/people/sandro/Sandro Head.png",
             grindr: "imgs/people/grindr/Grindr Head.png",
             house: "imgs/house.png",
             table: "imgs/table.png",
             savor: "imgs/savor.png",
             work: "imgs/work.png",
             biking: "imgs/biking.png",
             cook: "imgs/cook.png",
             exclamation: "imgs/exclamation.png",
             bar: "imgs/bar.png",
             biceps: "imgs/biceps.png",
             wave: "imgs/wave.png",
             cum: "imgs/cum.png",
         };

         const global_motion_graph = {
             nodes: {
                 "living_chair_1": [243, 1035],
                 "living_chair_1_seated": [243, 975],
                 "living_chair_2": [307, 1035],
                 "living_chair_2_seated": [307, 975],
                 "living_chair_3": [510, 1035],
                 "living_chair_3_seated": [510, 975],
                 "kitchen_chair_1": [675, 1035],
                 "kitchen_chair_1_seated": [675, 977],
                 "kitchen_chair_2": [725, 1035],
                 "kitchen_chair_2_seated": [725, 977],
                 "kitchen_chair_3": [777, 1035],
                 "kitchen_chair_3_seated": [777, 977],
                 "kitchen_chair_4": [827, 1035],
                 "kitchen_chair_4_seated": [827, 977],
                 "kitchen_stove": [967, 1035],
                 "kitchen_sink": [1100, 1035],
                 "kitchen_fridge": [1235, 1035],
                 "stairs_1_bottom": [1300, 1035],
                 "stairs_1_top": [1535, 763],
                 "stairs_2_bottom": [1300, 763],
                 "stairs_2_top": [1535, 490],
                 "desk_1": [242, 763],
                 "desk_1_seated": [242, 700],
                 "desk_2": [433, 763],
                 "desk_2_seated": [433, 700],
                 "bed_1": [685, 763], // Maybe adjust
                 "bed_2": [740, 763], // Maybe adjust
                 "tv_chair_1": [993, 763],
                 "tv_chair_1_seated": [993, 680],
                 "tv_chair_2": [1055, 763],
                 "tv_chair_2_seated": [1055, 680],
                 "bathroom_1": [210, 490],
                 "bathroom_2": [283, 490],
                 "bathroom_3": [356, 490],
                 "bathroom_4": [430, 490],
                 "gym_bar": [778, 490],
                 "gym_bike": [588, 490],
                 "gym_bike_seated": [588, 435],
                 "doorway_inside": [1510, 1035],
                 "doorway_outside": [1650, 1035],
                 "offscreen_1": [1900, 1035],
                 "offscreen_2": [1975, 1035],
                 "offscreen_3": [2050, 1035],
                 "offscreen_4": [2125, 1035],
             },
             edges: [
                 ["living_chair_1", "living_chair_2"],
                 ["living_chair_2", "living_chair_3"],
                 ["living_chair_3", "kitchen_chair_1"],
                 ["kitchen_chair_1", "kitchen_chair_2"],
                 ["kitchen_chair_2", "kitchen_chair_3"],
                 ["kitchen_chair_3", "kitchen_chair_4"],
                 ["kitchen_chair_4", "kitchen_stove"],
                 ["kitchen_stove", "kitchen_sink"],
                 ["kitchen_sink", "kitchen_fridge"],
                 ["kitchen_fridge", "stairs_1_bottom"],
                 ["stairs_1_bottom", "stairs_1_top"],
                 ["stairs_1_top", "stairs_2_bottom"],
                 ["stairs_2_bottom", "stairs_2_top"],
                 ["stairs_2_bottom", "tv_chair_2"],
                 ["tv_chair_2", "tv_chair_1"],
                 ["tv_chair_1", "bed_2"],
                 ["bed_2", "bed_1"],
                 ["bed_1", "desk_2"],
                 ["desk_2", "desk_1"],
                 ["stairs_2_top", "gym_bar"],
                 ["gym_bar", "gym_bike"],
                 ["gym_bike", "bathroom_4"],
                 ["bathroom_4", "bathroom_3"],
                 ["bathroom_3", "bathroom_2"],
                 ["bathroom_2", "bathroom_1"],
                 ["living_chair_1", "living_chair_1_seated"],
                 ["living_chair_2", "living_chair_2_seated"],
                 ["living_chair_3", "living_chair_3_seated"],
                 ["kitchen_chair_1", "kitchen_chair_1_seated"],
                 ["kitchen_chair_2", "kitchen_chair_2_seated"],
                 ["kitchen_chair_3", "kitchen_chair_3_seated"],
                 ["kitchen_chair_4", "kitchen_chair_4_seated"],
                 ["desk_1", "desk_1_seated"],
                 ["desk_2", "desk_2_seated"],
                 ["tv_chair_1", "tv_chair_1_seated"],
                 ["tv_chair_2", "tv_chair_2_seated"],
                 ["gym_bike", "gym_bike_seated"],
                 ["stairs_1_bottom", "doorway_inside"],
                 ["doorway_inside", "doorway_outside"],
                 ["doorway_outside", "offscreen_1"],
                 ["offscreen_1", "offscreen_2"],
                 ["offscreen_2", "offscreen_3"],
                 ["offscreen_3", "offscreen_4"],
             ],
         };

         function continue_motion_at(node) {
             return (world, person) => {
                 return new ContinueMotionAni(person.params, node);
             };
         }

         function continue_sitting_at(node, {text = null, image = null} = {}) {
             const seated_node = node + "_seated";
             return (world, person) => {
                 var speech = null;
                 if (text !== null) {
                     speech = text;
                 } else if (image !== null) {
                     speech = world.images[image];
                 }
                 return new SequentialAni([
                     new WalkAni(person.params, node, seated_node, {layer: "behind_table"}),
                     new ContinueMotionAni(person.params, seated_node, {layer: "behind_table", speech: speech}),
                     new WalkAni(person.params, seated_node, node, {layer: "behind_table"}),
                 ]);
             };
         }

         function watch_tv_at(node) {
             const seated_node = node + "_seated";
             return (world, person) => {
                 return new SequentialAni([
                     new WalkAni(person.params, node, seated_node),
                     new SimultaneousAni([
                         new ContinueMotionAni(person.params, seated_node),
                         new TvFlickerAni(),
                     ]),
                     new WalkAni(person.params, seated_node, node),
                 ]);
             };
         }

         function lift_weights() {
             return (world, person) => {
                 return new SequentialAni([
                     new StopMotionAni(person.params, "gym_bar"),
                     new StartMotionAni(person.params, "gym_bar", {
                         layer: "behind_table", draw_fn: draw_weight_lifting}),
                     new ContinueMotionAni(person.params, "gym_bar", {
                         layer: "behind_table", draw_fn: draw_weight_lifting, speech: world.images.biceps}),
                     new StopMotionAni(person.params, "gym_bar", {
                         layer: "behind_table", draw_fn: draw_weight_lifting, speech: world.images.biceps}),
                     new StartMotionAni(person.params, "gym_bar"),
                 ]);
             };
         }

         const global_simple_targets = {
             "living_chair_1": continue_sitting_at("living_chair_1"),
             "living_chair_2": continue_sitting_at("living_chair_2"),
             "living_chair_3": continue_sitting_at("living_chair_3"),
             /* "kitchen_chair_1": continue_sitting_at("kitchen_chair_1"),
              * "kitchen_chair_2": continue_sitting_at("kitchen_chair_2"),
              * "kitchen_chair_3": continue_sitting_at("kitchen_chair_3"),
              * "kitchen_chair_4": continue_sitting_at("kitchen_chair_4"),*/
             // "kitchen_cooking": continue_waving_at("kitchen_cooking"),
             "desk_1": continue_sitting_at("desk_1", {image: "work"}),
             "desk_2": continue_sitting_at("desk_2", {image: "work"}),
             "tv_chair_1": watch_tv_at("tv_chair_1"),
             "tv_chair_2": watch_tv_at("tv_chair_2"),
             "gym_bar": lift_weights(),
             "gym_bike": continue_sitting_at("gym_bike", {image: "biking"}),
         };

         function get_held_resources(world) {
             var resources = [];
             for (const [name, person] of Object.entries(world.people)) {
                 if (person.location !== null) {
                     resources.push(person.location);
                 }
                 if (person.next_location !== null) {
                     resources.push(person.next_location);
                 }
             }
             return new Set(resources);
         }

         function get_available_simple_targets(world) {
             const held_resources = get_held_resources(world);
             var available_targets = {};
             for (const [key, value] of Object.entries(global_simple_targets)) {
                 if (!held_resources.has(key)) {
                     available_targets[key] = value;
                 }
             }
             return available_targets;
         }

         function get_random_key_value(d) {
             const arr = Object.entries(d);
             if (arr.length == 0) {
                 return null;
             }
             return arr[Math.floor(Math.random() * arr.length)];
         }

         function set_starting_state(world, person) {
             const targets = get_available_simple_targets(world);
             const kv = get_random_key_value(targets);
             if (kv === null) {
                 return;
             }
             const [location, make_ani_fn] = kv;
             person.animation = new ContinueMotionAni(person.params, location);
             person.location = location;
         }
         
         function get_graph_neighbors() {
             var neighbors = {};
             for (var [n1, n2] of global_motion_graph.edges) {
                 if (!neighbors.hasOwnProperty(n1)) neighbors[n1] = [];
                 if (!neighbors.hasOwnProperty(n2)) neighbors[n2] = [];
                 neighbors[n1].push(n2);
                 neighbors[n2].push(n1);
             }
             return neighbors;
         }

         function get_path(start_node, end_node) {
             // Get neighbors of each node.
             const neighbors = get_graph_neighbors();

             // DFS the graph from start_node.
             var backtrace = {[start_node]: null};
             var queue = [start_node];
             while (queue.length > 0) {
                 const current = queue.shift();
                 for (const next of neighbors[current]) {
                     if (backtrace.hasOwnProperty(next)) continue;
                     backtrace[next] = current;
                     queue.push(next);
                 }
             }

             // Construct the path by following backtraces from end_node.
             var path = [];
             var node = end_node;
             while (node !== null && node !== undefined) {
                 path.push(node);
                 node = backtrace[node];
             }
             path.reverse();
             return path;
         }

         function lerp(a, b, t) {
             return a + (b - a) * t;
         }

         // Returns {p: [x, y], finished: bool}.
         function get_point_along_path(path, pixels) {
             for (var i = 0; i < path.length - 1; i += 1) {
                 const [x1, y1] = global_motion_graph.nodes[path[i]];
                 const [x2, y2] = global_motion_graph.nodes[path[i+1]];
                 const distance = Math.sqrt((x2 - x1)**2 + (y2 - y1)**2);
                 if (pixels <= distance) {
                     const frac = pixels / distance;
                     const x = lerp(x1, x2, frac);
                     const y = lerp(y1, y2, frac);
                     return {
                         p: [x, y],
                         finished: false,
                     };
                 }
                 pixels -= distance;
             }

             // If we get here, we've finished the path.
             return {
                 p: global_motion_graph.nodes[path[path.length-1]],
                 finished: true,
             };
         }

         function make_person(head_image, arm_color, body_color, bounce_period, arm_period, top_proclivity, accessory = false) {
             return {
                 params: {
                     head_image: head_image,
                     scale: 0.25,
                     arm_color: arm_color,
                     body_color: body_color,
                     bounce: {
                         offset_ms: 0,
                         period_ms: bounce_period,
                     },
                     arm: {
                         offset_ms: 0,
                         period_ms: arm_period,
                     },
                     walking_speed_pps: 150,
                     top_proclivity: top_proclivity,
                     accessory: accessory,
                 },
                 animation: null,
                 next_action_time: null,
                 location: null,
                 event: null,
                 next_animation: null,
                 next_location: null,
                 next_event: null,
             };
         }

         function get_image_promise([key, url]) {
             return new Promise((resolve, reject) => {
                 const image = new Image();
                 image.src = url;
                 image.onload = () => { resolve({[key]: image}); };
                 image.onerror = () => { reject("Failed to load: " + url); };
             });
         }

         // Returns a promise that resolves to a map of all the images once they are loaded.
         function load_images() {
             const promises = Object.entries(global_image_urls).map(get_image_promise);
             return Promise.all(promises).then((key_value_array) => {
                 // Convert key-value array to dictionary.
                 return Object.assign({}, ...key_value_array);
             });
         }

         function draw_arm(ctx, color, shoulder_x, shoulder_y, radius, length, rotation) {
             ctx.save();
             ctx.fillStyle = color;

             ctx.translate(shoulder_x, shoulder_y);
             ctx.rotate(rotation);

             ctx.beginPath();
             ctx.arc(0, 0, radius, 0, 2 * Math.PI);
             ctx.fill();

             ctx.beginPath();
             ctx.arc(0, length, radius, 0, 2 * Math.PI);
             ctx.fill();

             ctx.fillRect(-radius, 0, 2 * radius, length);

             ctx.restore();
         }

         function draw_arm_lifting(ctx, color, shoulder_x, shoulder_y, radius, offset) {
             ctx.save();
             ctx.fillStyle = color;

             ctx.translate(shoulder_x, shoulder_y);

             ctx.beginPath();
             ctx.arc(0, 0, radius, 0, 2 * Math.PI);
             ctx.fill();

             ctx.beginPath();
             ctx.arc(0, offset, radius, 0, 2 * Math.PI);
             ctx.fill();

             if (offset > 0) {
                 ctx.fillRect(-radius, 0, 2 * radius, offset);
             } else {
                 ctx.fillRect(-radius, offset, 2 * radius, -offset);
             }

             ctx.restore();
         }

         function eased(time_ms, period_ms) {
             const offset_ms = time_ms % period_ms;
             return 0.5 - Math.cos(offset_ms / period_ms * 2 * Math.PI) / 2.0;
         }

         function get_wave_params_cyclic(person, current_time) {
             return {
                 arm_t: eased(current_time + person.arm.offset_ms, person.arm.period_ms),
                 bounce_t: eased(current_time + person.bounce.offset_ms, person.bounce.period_ms),
             };
         }

         function can_start(current_time, animation_start_time, p) {
             const start_offset = (animation_start_time + p.offset_ms) % p.period_ms;
             const till_end = p.period_ms - start_offset;
             const elapsed = current_time - animation_start_time;
             return elapsed > till_end;
         }

         function can_stop(current_time, animation_start_time, p) {
             const start_iter = Math.floor((animation_start_time + p.offset_ms) / p.period_ms);
             const current_iter = Math.floor((current_time + p.offset_ms) / p.period_ms);
             return current_iter > start_iter;
         }

         function get_wave_params_from_rest(person, current_time, animation_start_time) {
             const can_start_arms = can_start(current_time, animation_start_time, person.arm);
             const can_start_bounce = can_start(current_time, animation_start_time, person.bounce);
             return {
                 arm_t: can_start_arms ?
                        eased(current_time + person.arm.offset_ms, person.arm.period_ms) :
                        0.0,
                 bounce_t: can_start_bounce ?
                           eased(current_time + person.bounce.offset_ms, person.bounce.period_ms) :
                           0.0,
                 done: can_start_arms && can_start_bounce,
             };
         }

         function get_wave_params_to_rest(person, current_time, animation_start_time) {
             const can_stop_arms = can_stop(current_time, animation_start_time, person.arm);
             const can_stop_bounce = can_stop(current_time, animation_start_time, person.bounce);
             return {
                 arm_t: can_stop_arms ?
                        0.0 :
                        eased(current_time + person.arm.offset_ms, person.arm.period_ms),
                 bounce_t: can_stop_bounce ?
                           0.0 :
                           eased(current_time + person.bounce.offset_ms, person.bounce.period_ms),
                 done: can_stop_arms && can_stop_bounce,
             };
         }

         function draw_speech(ctx, params, bounce_amount) {
             if (params.speech !== null && params.speech !== undefined) {
                 ctx.fillStyle = "white";
                 ctx.strokeStyle = "black";
                 ctx.font = "75px Inter";
                 const x_base = 50 + 70 + 170/2;
                 var speech_width = 0;
                 var speech_height = 0;
                 var text_x = 0;
                 var text_y = 0;
                 if (typeof params.speech === 'string') {
                     const measure = ctx.measureText(params.speech);
                     speech_width = measure.width + 100;
                     speech_height = measure.actualBoundingBoxAscent + measure.actualBoundingBoxDescent + 100;
                     text_x = x_base - measure.width / 2;
                     text_y = -30 - 50 - measure.actualBoundingBoxDescent;
                 } else {
                     speech_width = params.speech.width + 50;
                     speech_height = params.speech.height + 50;
                 }
                 ctx.beginPath();
                 ctx.moveTo(x_base, bounce_amount);
                 ctx.lineTo(x_base + 30, -30);
                 ctx.lineTo(x_base + speech_width/2, -30);
                 ctx.lineTo(x_base + speech_width/2, -speech_height - 30);
                 ctx.lineTo(x_base - speech_width/2, -speech_height - 30);
                 ctx.lineTo(x_base - speech_width/2, -30);
                 ctx.lineTo(x_base - 30, -30);
                 ctx.lineTo(x_base, bounce_amount);
                 ctx.fill();
                 ctx.stroke();
                 if (typeof params.speech === 'string') {
                     ctx.fillStyle = "black";
                     ctx.fillText(params.speech, text_x, text_y);
                 } else {
                     ctx.drawImage(params.speech, x_base - speech_width/2 + 50/2, -speech_height - 30 + 50/2);
                 }
             }
         }

         function draw_nominal(params) {
             var canvas = document.getElementById("c");
             var ctx = canvas.getContext("2d");
             ctx.resetTransform();

             const bounce_amount = params.bounce_t * 20;

             const top = 320 + bounce_amount;
             const bottom = 320 + 200;
             const left = 70;

             ctx.scale(params.scale, params.scale);
             ctx.translate(-(50 + left + 170/2), -bottom);
             ctx.translate(params.x / params.scale, params.y / params.scale);

             ctx.fillStyle = params.body_color;
             ctx.fillRect(50 + left, top, 170, (bottom - top));

             ctx.beginPath();
             ctx.arc(50 + left + 170/2, top, 170/2, 0, 2 * Math.PI);
             ctx.fill();

             const arm_offset_x = 10;
             const arm_offset_y = -30;
             draw_arm(ctx, params.arm_color, 50 + left + arm_offset_x, top + arm_offset_y, 20, 100, 2.5 * params.arm_t);
             draw_arm(ctx, params.arm_color, 50 + left + 170 - arm_offset_x, top + arm_offset_y, 20, 100, -2.5 * params.arm_t);

             ctx.drawImage(params.head_image, 30 + left, bounce_amount);

             draw_speech(ctx, params, bounce_amount);
             
             ctx.resetTransform();
         }

         function draw_weight_lifting(params) {
             var canvas = document.getElementById("c");
             var ctx = canvas.getContext("2d");
             ctx.resetTransform();

             ctx.fillStyle = "#fde3a8";
             ctx.fillRect(690, 420, 173, 47);

             const top = 320;
             const bottom = 320 + 200;
             const left = 70;

             ctx.scale(params.scale, params.scale);
             ctx.translate(-(50 + left + 170/2), -bottom);
             ctx.translate(params.x / params.scale, params.y / params.scale);

             ctx.fillStyle = params.body_color;
             ctx.fillRect(50 + left, top, 170, (bottom - top));

             ctx.beginPath();
             ctx.arc(50 + left + 170/2, top, 170/2, 0, 2 * Math.PI);
             ctx.fill();
             
             ctx.drawImage(params.head_image, 30 + left, 0);

             const arm_offset_x = 10;
             const arm_offset_y = -30;
             const arm_offset = 75 - 200 * params.arm_t;
             draw_arm_lifting(ctx, params.arm_color, 50 + left + arm_offset_x, top + arm_offset_y, 20, arm_offset);
             draw_arm_lifting(ctx, params.arm_color, 50 + left + 170 - arm_offset_x, top + arm_offset_y, 20, arm_offset);

             draw_speech(ctx, params, 0);
             
             ctx.resetTransform();
             ctx.scale(0.25, 0.25);
             ctx.translate(0, -500);
             ctx.translate(0, arm_offset - 80);
             ctx.drawImage(global_world.images.bar, 0, 0);
             
             ctx.resetTransform();
         }

         function draw_topping(params) {
             var canvas = document.getElementById("c");
             var ctx = canvas.getContext("2d");
             ctx.resetTransform();

             const position_t = params.hookup_t < 0.05 ? params.hookup_t / 0.05
                                                       : params.hookup_t > 0.95 ? (1.0 - params.hookup_t) / 0.05
                                                                                : 1.0;

             const thrust_t = position_t == 1.0 ? (params.hookup_t % 0.025) / 0.025 : 0.0;
             const thrust_max_offset = 20;
             const thrust_offset =
                 (thrust_t < 0.25 ? thrust_t / 0.25 * thrust_max_offset
                                  : thrust_t < 0.5 ? thrust_max_offset
                                                   : (1.0 - thrust_t) / 0.5 * thrust_max_offset);
             const x = params.x - thrust_offset;
             const y = params.y - 30 * position_t;

             if (position_t === 1.0 && params.hookup_t >= 0.7) {
                 params.speech = params.cum;
             }

             const top = 320;
             const bottom = 320 + 200;
             const left = 70;

             ctx.scale(params.scale, params.scale);
             ctx.translate(-(50 + left + 170/2), -bottom);
             ctx.translate(x / params.scale, y / params.scale);

             ctx.fillStyle = params.body_color;
             ctx.fillRect(50 + left, top, 170, (bottom - top));

             ctx.beginPath();
             ctx.arc(50 + left + 170/2, top, 170/2, 0, 2 * Math.PI);
             ctx.fill();

             const arm_offset_x = 10;
             const arm_offset_y = -30;
             draw_arm(ctx, params.arm_color, 50 + left + arm_offset_x, top + arm_offset_y, 20, 100, 2.5 * params.arm_t);
             draw_arm(ctx, params.arm_color, 50 + left + 170 - arm_offset_x, top + arm_offset_y, 20, 100, -2.5 * params.arm_t);

             ctx.drawImage(params.head_image, 30 + left, 0);

             draw_speech(ctx, params, 0);
             
             ctx.resetTransform();
         }

         function draw_bottoming(params) {
             var canvas = document.getElementById("c");
             var ctx = canvas.getContext("2d");
             ctx.resetTransform();

             const position_t = params.hookup_t < 0.05 ? params.hookup_t / 0.05
                                                       : params.hookup_t > 0.95 ? (1.0 - params.hookup_t) / 0.05
                                                                                : 1.0;

             const thrust_t = position_t == 1.0 ? (params.hookup_t % 0.025) / 0.025 : 0.0;
             const thrust_max_offset = 20;
             const thrust_offset =
                 (thrust_t < 0.25 ? thrust_t / 0.25 * thrust_max_offset
                                  : thrust_t < 0.5 ? thrust_max_offset
                                                   : (1.0 - thrust_t) / 0.5 * thrust_max_offset);
             const x = params.x - thrust_offset;

             if (position_t === 1.0 && params.hookup_t >= 0.7) {
                 params.speech = params.cum;
             }

             const top = 320;
             const bottom = 320 + 200;
             const left = 70;

             ctx.scale(params.scale, params.scale);
             ctx.translate(-(50 + left + 170/2), -bottom);
             ctx.translate(x / params.scale, params.y / params.scale);
             ctx.translate(position_t * -150, position_t * 500);
             ctx.rotate(position_t * -Math.PI / 2.0);

             ctx.fillStyle = params.body_color;
             ctx.fillRect(50 + left, top, 170, (bottom - top));

             ctx.beginPath();
             ctx.arc(50 + left + 170/2, top, 170/2, 0, 2 * Math.PI);
             ctx.fill();

             const arm_offset_x = 10;
             const arm_offset_y = -30;
             draw_arm(ctx, params.arm_color, 50 + left + arm_offset_x, top + arm_offset_y, 20, 100, 2.5 * params.arm_t);
             draw_arm(ctx, params.arm_color, 50 + left + 170 - arm_offset_x, top + arm_offset_y, 20, 100, -2.5 * params.arm_t);

             ctx.drawImage(params.head_image, 30 + left, 0);

             draw_speech(ctx, params, 0);
             
             ctx.resetTransform();
         }

         // The API for an animation is:
         //  * it has a tick() method that draws and returns whether the animation is done.
         //  * it has a request_done() method.
         //  * it has a can_request_done() method that returns true or false.

         class StartMotionAni {
             constructor(person_params, node, {layer = "", draw_fn = draw_nominal, speech = null} = {}) {
                 this.person_params = person_params;
                 [this.x, this.y] = global_motion_graph.nodes[node];
                 this.layer = layer;
                 this.draw_fn = draw_fn;
                 this.speech = speech;
                 this.start_time = null;
             }

             tick(current_time, layer) {
                 if (this.layer !== layer) {
                     return false;
                 }
                 if (this.start_time === null) {
                     this.start_time = current_time;
                 }
                 var params = {
                     x: this.x,
                     y: this.y,
                     speech: this.speech,
                 };
                 Object.assign(params, this.person_params);
                 Object.assign(params, get_wave_params_from_rest(this.person_params, current_time, this.start_time));
                 this.draw_fn(params);
                 return params.done;
             }

             request_done() {}
             
             can_request_done() { return false; }
         }

         class StopMotionAni {
             constructor(person_params, node, {layer = "", draw_fn = draw_nominal, speech = null} = {}) {
                 this.person_params = person_params;
                 [this.x, this.y] = global_motion_graph.nodes[node];
                 this.layer = layer;
                 this.draw_fn = draw_fn;
                 this.speech = speech;
                 this.start_time = null;
             }

             tick(current_time, layer) {
                 if (this.layer !== layer) {
                     return false;
                 }
                 if (this.start_time === null) {
                     this.start_time = current_time;
                 }
                 var params = {
                     x: this.x,
                     y: this.y,
                     speech: this.speech,
                 };
                 Object.assign(params, this.person_params);
                 Object.assign(params, get_wave_params_to_rest(this.person_params, current_time, this.start_time));
                 this.draw_fn(params);
                 return params.done;
             }

             request_done() {}
             
             can_request_done() { return false; }
         }

         class ContinueMotionAni {
             constructor(person_params, node, {layer = "", duration = null, speech = null, draw_fn = draw_nominal} = {}) {
                 this.person_params = person_params;
                 [this.x, this.y] = global_motion_graph.nodes[node];
                 this.layer = layer;
                 this.duration = duration;
                 this.speech = speech;
                 this.draw_fn = draw_fn;
                 this.start_time = null;
                 this.done = false;
             }

             tick(current_time, layer) {
                 if (this.layer !== layer) {
                     return false;
                 }
                 if (this.start_time === null) {
                     this.start_time = current_time;
                 }
                 if (this.duration !== null && current_time - this.start_time >= this.duration) {
                     this.done = true;
                 }
                 var params = {
                     x: this.x,
                     y: this.y,
                     speech: this.speech,
                 };
                 Object.assign(params, this.person_params);
                 Object.assign(params, get_wave_params_cyclic(this.person_params, current_time, this.start_time));
                 this.draw_fn(params);
                 return this.done;
             }

             request_done() {
                 this.done = true;
             }

             can_request_done() { return this.duration === null; }
         }

         class TvFlickerAni {
             constructor(duration = null) {
                 this.duration = duration;
                 this.transitions = [300, 700, 900, 1400, 1500, 1600, 1800];
                 const canvas = document.getElementById("c");
                 this.ctx = canvas.getContext("2d");
                 this.start_time = null;
                 this.done = false;
             }

             tick(current_time, layer) {
                 if (layer !== "") {
                     return false;
                 }
                 if (this.start_time === null) {
                     this.start_time = current_time;
                 }
                 if (this.duration !== null && current_time - this.start_time >= this.duration) {
                     this.done = true;
                 }
                 const offset = current_time % 2000;
                 const transition_count = this.transitions.filter(t => t < offset).length;
                 const color = (transition_count % 2 == 0) ? "white" : "black";
                 this.ctx.resetTransform();
                 this.ctx.fillStyle = color;
                 this.ctx.fillRect(1117, 525, 131, 65);
                 return this.done;
             }

             request_done() {
                 this.done = true;
             }

             can_request_done() { return this.duration === null; }
         }

         class WalkAni {
             constructor(person_params, start_node, end_node, {layer = "", speech = null} = {}) {
                 this.person_params = person_params;
                 this.start_node = start_node;
                 this.end_node = end_node;
                 this.layer = layer;
                 this.speech = speech;
                 this.path = get_path(start_node, end_node);
                 this.start_time = null;
             }

             tick(current_time, layer) {
                 if (this.layer !== layer) {
                     return false;
                 }
                 if (this.start_time === null) {
                     this.start_time = current_time;
                 }
                 const pixels = (current_time - this.start_time) / 1000 * this.person_params.walking_speed_pps;
                 const path_point = get_point_along_path(this.path, pixels);
                 var params = {
                     x: path_point.p[0],
                     y: path_point.p[1],
                     speech: this.speech,
                 };
                 Object.assign(params, this.person_params);
                 Object.assign(params, get_wave_params_cyclic(this.person_params, current_time, this.start_time));
                 draw_nominal(params);
                 return path_point.finished;
             }

             request_done() {}

             can_request_done() { return false; }
         }

         class WalkToAni {
             constructor(person, end_node, options = {}) {
                 this.person = person;
                 this.end_node = end_node;
                 this.options = options;
                 this.child_ani = null;
             }

             tick(current_time, layer) {
                 if (this.child_ani === null) {
                     this.child_ani = new WalkAni(this.person.params, this.person.location, this.end_node, this.options);
                 }
                 const done = this.child_ani.tick(current_time, layer);
                 if (done) {
                     this.person.location = this.end_node;
                 }
                 return done;
             }

             request_done() {}

             can_request_done() { return false; }
         }

         class HookupAni {
             constructor(world, person_params, node, draw_fn) {
                 this.world = world;
                 this.person_params = person_params;
                 [this.x, this.y] = global_motion_graph.nodes[node];
                 this.draw_fn = draw_fn;
                 this.start_time = null;
             }

             tick(current_time, layer) {
                 if (layer !== "behind_table") {
                     return false;
                 }
                 if (this.start_time === null) {
                     this.start_time = current_time;
                 }
                 const time = current_time - this.start_time;
                 const hookup_t = time / 16000;
                 var params = {
                     x: this.x,
                     y: this.y,
                     hookup_t: hookup_t,
                     cum: this.world.images.cum,
                 };
                 Object.assign(params, this.person_params);
                 this.draw_fn(params);
                 return hookup_t >= 1.0;
             }

             request_done() {}

             can_request_done() { return false; }
         }

         class SequentialAni {
             constructor(sequence) {
                 this.sequence = sequence;
                 this.current = 0;
             }

             tick(current_time, layer) {
                 const index = Math.min(this.current, this.sequence.length - 1);
                 const next = this.sequence[index].tick(current_time, layer);
                 if (next && this.current < this.sequence.length) {
                     this.current += 1;
                 }
                 return this.current >= this.sequence.length;
             }

             request_done() {
                 this.sequence.map((a) => { a.request_done(); });
             }

             can_request_done() {
                 const index = Math.min(this.current, this.sequence.length - 1);
                 return this.sequence[index].can_request_done();
             }
         }

         class SimultaneousAni {
             constructor(children) {
                 this.children = children;
             }

             tick(current_time, layer) {
                 var done = true;
                 for (const child of this.children) {
                     done &= child.tick(current_time, layer);
                 }
                 return done;
             }

             request_done() {
                 this.children.map((a) => { a.request_done(); });
             }

             can_request_done() {
                 return this.children.every((a) => { return a.can_request_done(); });
             }
         }

         class Event {
             constructor(world, stages) {
                 this.world = world;
                 this.stages = stages;
                 this.current = 0;
                 this.people = {};
                 this.people_done = new Set();
             }

             tick(current_time, layer) {
                 const index = Math.min(this.current, this.stages.length - 1);
                 const stage = this.stages[index];

                 // Update people.
                 for (const person in stage) {
                     this.people[person] = this.world.people[person];
                 }

                 // Try to acquire everyone that hasn't been acquired yet.
                 for (const [name, person] of Object.entries(this.people)) {
                     if (person.event !== this && person.next_event !== this) {
                         if (person.params.accessory) {
                             // If this is an accessory person, we can just grab them immediately.
                             person.event = this;
                         } else {
                             // Otherwise we have to queue ourselves.
                             person.next_event = this;
                         }
                     }
                 }

                 // Count the number of acquired people.
                 var num_acquired = 0;
                 for (const [name, person] of Object.entries(this.people)) {
                     if (person.event === this) {
                         num_acquired += 1;
                     }
                 }
                 const num_people = Object.keys(this.people).length;
                 const all_acquired = (num_acquired === num_people);

                 // Deal with all the people.
                 for (const [name, person] of Object.entries(this.people)) {
                     if (person.event !== this) {
                         continue;
                     }
                     
                     var desired_ani = stage[name];
                     if (desired_ani === undefined) desired_ani = null;
                     if (all_acquired && desired_ani !== null && person.animation !== desired_ani) {
                         var done = true;
                         if (person.animation !== null) {
                             person.animation.request_done();
                             done = person.animation.tick(current_time, layer);
                         }
                         if (done) {
                             person.animation = desired_ani;
                             person.next_action_time = null;
                             person.next_animation = null;
                             person.next_location = null;
                         }
                     } else if (all_acquired && desired_ani === null) {
                         var done = true;
                         if (person.animation !== null) {
                             done = person.animation.tick(current_time, layer);
                             done |= person.animation.can_request_done();
                         }
                         if (done) {
                             this.people_done.add(name);
                         }
                     } else if (all_acquired) {
                         var done = true;
                         if (person.animation !== null) {
                             done = person.animation.tick(current_time, layer);
                         }
                         if (done) {
                             this.people_done.add(name);
                         }
                     } else if (person.animation !== null) {
                         person.animation.tick(current_time, layer);
                     }
                 }

                 // Check if we can move on to the next stage.
                 const num_done = this.people_done.size;
                 if (num_done === num_people && this.current < this.stages.length) {
                     this.current += 1;
                     this.people_done = new Set();
                 }

                 // Check if we are done overall.
                 const done_overall = this.current >= this.stages.length;
                 if (done_overall) {
                     for (const [name, person] of Object.entries(this.people)) {
                         person.event = null;
                         person.next_action_time = current_time;
                     }
                 }
                 return done_overall;
             }
         }

         class EventManager {
             constructor(world) {
                 this.world = world;
                 this.event = null;
                 this.last_event_finish_time = new Date().getTime();
                 this.index = 0;
             }

             tick(current_time, layer) {
                 if (this.event !== null) {
                     // Animate the currently-active event.
                     const done = this.event.tick(current_time, layer);
                     if (done) {
                         this.event = null;
                         this.last_event_finish_time = current_time;
                     }
                 } else {
                     // Maybe set up a new event.
                     if (current_time - this.last_event_finish_time > 1000) {
                         this.event = this.create_event();
                         console.log("installed event!");
                     }
                 }
             }

             create_dinner_event(sequence_number) {
                 const possible_cooks = ["steve", "david", "sandro", "carlos"];
                 const cook = possible_cooks[sequence_number % possible_cooks.length];
                 return dinner_event(this.world, cook);
             }

             create_hookup_event(sequence_number) {
                 const possible_hosts = ["carlos", "steve", "david"];
                 const host = possible_hosts[sequence_number % possible_hosts.length];
                 return hookup_event(this.world, host);
             }
             
             create_event() {
                 const event_creators = [
                     s => this.create_hookup_event(s),
                     s => this.create_dinner_event(s),
                 ];
                 const event_type = this.index % event_creators.length;
                 const event_sequence_number = Math.floor(this.index / event_creators.length);
                 const event = event_creators[event_type](event_sequence_number);
                 this.index += 1;
                 return event;
             }
         }

         function animate(world, current_time, layer) {
             // Animate the people.
             for (var [name, person] of Object.entries(world.people)) {
                 if (person.animation === null) {
                     // Nothing to animate.
                     continue;
                 }

                 if (person.event !== null) {
                     // This person is participating in an event; let the event handle animation.
                     continue;
                 }

                 if (person.params.accessory) {
                     // This person is an accessory; only animate them during events.
                     continue;
                 }

                 const done = person.animation.tick(current_time, layer);

                 if (person.next_action_time === null) {
                     // Case 1: not yet in the steady-state for this animation.
                     const in_steady_state = done || person.animation.can_request_done();
                     if (in_steady_state) {
                         person.next_action_time = current_time + 3000; // TODO tweak.
                     }
                 } else if (current_time < person.next_action_time) {
                     // Case 2: waiting for the correct time to start the next animation.
                 } else if (person.next_animation === null && person.next_event === null) {
                     // Case 3: try to pick another animation.
                     const targets = get_available_simple_targets(world);
                     const kv = get_random_key_value(targets);
                     if (kv !== null) {
                         const [location, make_ani_fn] = kv;
                         person.next_location = location;
                         person.next_animation = new SequentialAni([
                             new WalkAni(person.params, person.location, person.next_location),
                             make_ani_fn(world, person),
                         ]);
                         person.animation.request_done();
                     }
                 } else if (person.next_animation === null && person.next_event !== null) {
                     // Case 4: ready to move on to the event.
                     person.event = person.next_event;
                     person.next_event = null;
                 } else if (!done) {
                     // Case 5: waiting for current animation to be done so we can start the next one.
                 } else {
                     // Case 6: move on to the next animation.
                     person.animation = person.next_animation;
                     person.next_action_time = null;
                     person.location = person.next_location;
                     person.next_animation = null;
                     person.next_location = null;
                 }
             }

             // Animate the currently-active event, if any.
             world.event_manager.tick(current_time, layer);
         }
         
         function set_up_animation_loop(world) {
             function tick() {
                 const current_time = new Date().getTime();

                 // Clear.
                 var canvas = document.getElementById("c");
                 var ctx = canvas.getContext("2d");
                 ctx.resetTransform();
                 ctx.clearRect(0, 0, canvas.width, canvas.height);

                 // Draw house.
                 ctx.scale(0.25, 0.25);
                 ctx.translate(0, -500);
                 ctx.drawImage(world.images.house, 0, 0);

                 // Animate behind_table layer.
                 animate(world, current_time, "behind_table");
                 
                 // Draw table.
                 ctx.resetTransform();
                 ctx.scale(0.25, 0.25);
                 ctx.translate(0, -500);
                 ctx.drawImage(world.images.table, 0, 0);
                 ctx.resetTransform();

                 // Animate default layer.
                 animate(world, current_time, /*layer=*/"");

                 window.requestAnimationFrame(tick);
             }
             window.requestAnimationFrame(tick);
         }

         function dinner_event(world, cook_name) {
             const cook = world.people[cook_name];
             var non_cooks = new Set(["steve", "david", "sandro", "carlos"]);
             non_cooks.delete(cook_name);
             non_cooks = [...non_cooks];
             non_cooks = non_cooks
                 .map((p) => [p, Math.random()])
                 .sort((a, b) => a[1] - b[1])
                 .map(([p, order]) => p)
                 .map((name) => [name, world.people[name]]);
             
             const stage_1 = {
                 [cook_name]: new SequentialAni([
                     new WalkToAni(cook, "kitchen_fridge"),
                     new ContinueMotionAni(cook.params, "kitchen_fridge", {duration: 2000, speech: world.images.cook}),
                     new WalkToAni(cook, "kitchen_stove", {speech: world.images.cook}),
                     new ContinueMotionAni(cook.params, "kitchen_stove", {duration: 2000, speech: world.images.cook}),
                     new WalkToAni(cook, "kitchen_sink", {speech: world.images.cook}),
                     new ContinueMotionAni(cook.params, "kitchen_sink", {duration: 2000, speech: world.images.cook}),
                     new WalkToAni(cook, "kitchen_fridge", {speech: world.images.cook}),
                     new ContinueMotionAni(cook.params, "kitchen_fridge", {duration: 2000, speech: world.images.cook}),
                     new WalkToAni(cook, "kitchen_stove", {speech: world.images.cook}),
                     new ContinueMotionAni(cook.params, "kitchen_stove", {duration: 2000, speech: world.images.cook}),
                 ]),
             };

             const stage_2 = {
                 [cook_name]: new ContinueMotionAni(cook.params, "kitchen_stove", {duration: 0, speech: world.images.cook}),
             };
             for (const [name, person] of non_cooks) {
                 stage_2[name] = null;
             }

             const stage_3 = {
                 [cook_name]: new ContinueMotionAni(cook.params, "kitchen_stove", {duration: 0, speech: "Dinner's ready!"}),
             };
             for (var i = 0; i < non_cooks.length; i += 1) {
                 const [name, person] = non_cooks[i];
                 const chair_node = "kitchen_chair_" + (i + 1);
                 const chair_node_seated = chair_node + "_seated";
                 stage_3[name] = new SequentialAni([
                     new WalkToAni(person, chair_node, {speech: world.images.exclamation}),
                     new WalkToAni(person, chair_node_seated, {layer: "behind_table"}),
                 ]);
             }

             const stage_4 = {
                 [cook_name]: new SequentialAni([
                     new WalkToAni(cook, "kitchen_chair_4"),
                     new WalkToAni(cook, "kitchen_chair_4_seated", {layer: "behind_table"}),
                 ]),
             };

             const stage_5 = {};
             const people = non_cooks.concat([[cook_name, cook]]);
             for (var i = 0; i < people.length; i += 1) {
                 const [name, person] = people[i];
                 const chair_node = "kitchen_chair_" + (i + 1);
                 const chair_node_seated = chair_node + "_seated";
                 stage_5[name] = new SequentialAni([
                     new ContinueMotionAni(person.params, chair_node_seated, {duration: 8000, speech: world.images.savor, layer: "behind_table"}),
                     new WalkToAni(person, chair_node, {layer: "behind_table"}),
                     new ContinueMotionAni(person.params, chair_node, {duration: 0}),
                 ]);
             }

             return new Event(world, [stage_1, stage_2, stage_3, stage_4, stage_5]);
         }

         function hookup_event(world, host_name) {
             const host = world.people[host_name];
             const grindr = world.people.grindr;
             grindr.location = "offscreen_1";

             const host_will_top = Math.random() <= host.params.top_proclivity;
             const top_name = host_will_top ? host_name : "grindr";
             const bottom_name = host_will_top ? "grindr" : host_name;
             const top = world.people[top_name];
             const bottom = world.people[bottom_name];

             const stages = [{
                 [host_name]: null,
                 grindr: new SequentialAni([
                     new WalkToAni(grindr, "doorway_outside"),
                     new ContinueMotionAni(grindr.params, "doorway_outside", {duration: 0, speech: "Ding dong!"}),
                 ]),
             }, {
                 [host_name]: new WalkToAni(host, "doorway_inside", {speech: world.images.exclamation}),
                 grindr: new ContinueMotionAni(grindr.params, "doorway_outside", {duration: 0, speech: "Ding dong!"}),
             }, {
                 [host_name]: new ContinueMotionAni(host.params, "doorway_inside", {duration: 2000, speech: world.images.wave}),
                 grindr: new ContinueMotionAni(grindr.params, "doorway_outside", {duration: 2000, speech: world.images.wave}),
             }, {
                 [bottom_name]: new SequentialAni([
                     new WalkToAni(bottom, "bed_1"),
                     new StopMotionAni(bottom.params, "bed_1"),
                 ]),
                 [top_name]: new SequentialAni([
                     new WalkToAni(top, "bed_2"),
                     new StopMotionAni(top.params, "bed_2"),
                 ]),
             }, {
                 [bottom_name]: new SequentialAni([
                     new HookupAni(world, bottom.params, "bed_1", draw_bottoming),
                     new StartMotionAni(bottom.params, "bed_1"),
                 ]),
                 [top_name]: new SequentialAni([
                     new HookupAni(world, top.params, "bed_2", draw_topping),
                     new StartMotionAni(top.params, "bed_2"),
                 ]),
             }, {
                 [host_name]: new ContinueMotionAni(host.params, host_will_top ? "bed_2" : "bed_1", {
                     duration: 0, speech: world.images.wave}),
                 grindr: new WalkToAni(grindr, "offscreen_1"),
             }];

             return new Event(world, stages);
         }

         var global_world = null;
         
         function main() {
             load_images().then((images) => {
                 const world = {
                     images: images,
                     people: {
                         steve: make_person(
                             images.steve,
                             /*arm_color=*/"blue",
                             /*body_color=*/"green",
                             /*bounce_period=*/900,
                             /*arm_period=*/2200,
                             /*top_proclivity=*/0.8,
                         ),
                         david: make_person(
                             images.david,
                             /*arm_color=*/"blue",
                             /*body_color=*/"green",
                             /*bounce_period=*/1100,
                             /*arm_period=*/2000,
                             /*top_proclivity=*/0.2,
                         ),
                         carlos: make_person(
                             images.carlos,
                             /*arm_color=*/"blue",
                             /*body_color=*/"green",
                             /*bounce_period=*/800,
                             /*arm_period=*/1800,
                             /*top_proclivity=*/0.2,
                         ),
                         sandro: make_person(
                             images.sandro,
                             /*arm_color=*/"blue",
                             /*body_color=*/"green",
                             /*bounce_period=*/1000,
                             /*arm_period=*/1300,
                             /*top_proclivity=*/0.2,
                         ),
                         grindr: make_person(
                             images.grindr,
                             /*arm_color=*/"blue",
                             /*body_color=*/"green",
                             /*bounce_period=*/1200,
                             /*arm_period=*/1500,
                             /*top_proclivity=*/0.0,
                             /*accessory=*/true,
                         ),
                     },
                 };
                 world.event_manager = new EventManager(world);
                 global_world = world;
                 for (const [name, person] of Object.entries(world.people)) {
                     if (person.params.accessory) continue;
                     set_starting_state(world, person);
                 }
                 set_up_animation_loop(world);
             });
         }

         window.onload = main;
         console.log("test");
        </script>
    </head>
    <body>
        <canvas id="c" width="1750px" height="1100px"> </canvas>
    </body>
</html>
