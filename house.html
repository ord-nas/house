<!DOCTYPE html>
<html>
    <head>
        <script type="text/javascript">
         const global_image_urls = {
             steve: "imgs/people/steve/Steve Head.png",
             david: "imgs/people/david/David Head.png",
             carlos: "imgs/people/carlos/Carlos Head.png",
             sandro: "imgs/people/sandro/Sandro Head.png",
             house: "imgs/house.png",
             table: "imgs/table.png",
         };

         const global_motion_graph = {
             nodes: {
                 "living_chair_1": [243, 1035],
                 "living_chair_1_seated": [243, 975],
                 "living_chair_2": [307, 1035],
                 "living_chair_2_seated": [307, 975],
                 "living_chair_3": [510, 1035],
                 "living_chair_3_seated": [510, 975],
                 "kitchen_chair_1": [675, 1035],
                 "kitchen_chair_1_seated": [675, 977],
                 "kitchen_chair_2": [725, 1035],
                 "kitchen_chair_2_seated": [725, 977],
                 "kitchen_chair_3": [777, 1035],
                 "kitchen_chair_3_seated": [777, 977],
                 "kitchen_chair_4": [827, 1035],
                 "kitchen_chair_4_seated": [827, 977],
                 "kitchen_cooking": [1000, 1035],
                 "stairs_1_bottom": [1300, 1035],
                 "stairs_1_top": [1535, 763],
                 "stairs_2_bottom": [1300, 763],
                 "stairs_2_top": [1535, 490],
                 "desk_1": [242, 763],
                 "desk_1_seated": [242, 700],
                 "desk_2": [433, 763],
                 "desk_2_seated": [433, 700],
                 "bed_1": [685, 763], // Maybe adjust
                 "bed_2": [740, 763], // Maybe adjust
                 "tv_chair_1": [993, 763],
                 "tv_chair_1_seated": [993, 680],
                 "tv_chair_2": [1055, 763],
                 "tv_chair_2_seated": [1055, 680],
                 "bathroom_1": [210, 490],
                 "bathroom_2": [283, 490],
                 "bathroom_3": [356, 490],
                 "bathroom_4": [430, 490],
                 "gym": [778, 490],
             },
             edges: [
                 ["living_chair_1", "living_chair_2"],
                 ["living_chair_2", "living_chair_3"],
                 ["living_chair_3", "kitchen_chair_1"],
                 ["kitchen_chair_1", "kitchen_chair_2"],
                 ["kitchen_chair_2", "kitchen_chair_3"],
                 ["kitchen_chair_3", "kitchen_chair_4"],
                 ["kitchen_chair_4", "kitchen_cooking"],
                 ["kitchen_cooking", "stairs_1_bottom"],
                 ["stairs_1_bottom", "stairs_1_top"],
                 ["stairs_1_top", "stairs_2_bottom"],
                 ["stairs_2_bottom", "stairs_2_top"],
                 ["stairs_2_bottom", "tv_chair_2"],
                 ["tv_chair_2", "tv_chair_1"],
                 ["tv_chair_1", "bed_2"],
                 ["bed_2", "bed_1"],
                 ["bed_1", "desk_2"],
                 ["desk_2", "desk_1"],
                 ["stairs_2_top", "gym"],
                 ["gym", "bathroom_4"],
                 ["bathroom_4", "bathroom_3"],
                 ["bathroom_3", "bathroom_2"],
                 ["bathroom_2", "bathroom_1"],
                 ["living_chair_1", "living_chair_1_seated"],
                 ["living_chair_2", "living_chair_2_seated"],
                 ["living_chair_3", "living_chair_3_seated"],
                 ["kitchen_chair_1", "kitchen_chair_1_seated"],
                 ["kitchen_chair_2", "kitchen_chair_2_seated"],
                 ["kitchen_chair_3", "kitchen_chair_3_seated"],
                 ["kitchen_chair_4", "kitchen_chair_4_seated"],
                 ["desk_1", "desk_1_seated"],
                 ["desk_2", "desk_2_seated"],
                 ["tv_chair_1", "tv_chair_1_seated"],
                 ["tv_chair_2", "tv_chair_2_seated"],
             ],
         };

         function continue_waving_at(node) {
             return (person) => {
                 return new ContinueWavingAni(person.params, node);
             };
         }

         function continue_sitting_at(node) {
             const seated_node = node + "_seated";
             return (person) => {
                 return new SequentialAni([
                     new WalkAni(person.params, node, seated_node, "behind_table"),
                     new ContinueWavingAni(person.params, seated_node, "behind_table"),
                     new WalkAni(person.params, seated_node, node, "behind_table"),
                 ]);
             };
         }

         const global_simple_targets = {
             "living_chair_1": continue_sitting_at("living_chair_1"),
             "living_chair_2": continue_sitting_at("living_chair_2"),
             "living_chair_3": continue_sitting_at("living_chair_3"),
             /* "kitchen_chair_1": continue_sitting_at("kitchen_chair_1"),
              * "kitchen_chair_2": continue_sitting_at("kitchen_chair_2"),
              * "kitchen_chair_3": continue_sitting_at("kitchen_chair_3"),
              * "kitchen_chair_4": continue_sitting_at("kitchen_chair_4"),*/
             "kitchen_cooking": continue_waving_at("kitchen_cooking"),
             "desk_1": continue_sitting_at("desk_1"),
             "desk_2": continue_sitting_at("desk_2"),
             "tv_chair_1": continue_sitting_at("tv_chair_1"),
             "tv_chair_2": continue_sitting_at("tv_chair_2"),
             "gym": continue_waving_at("gym"),
         };

         function get_held_resources(world) {
             var resources = [];
             for (const [name, person] of Object.entries(world.people)) {
                 if (person.location !== null) {
                     resources.push(person.location);
                 }
                 if (person.next_location !== null) {
                     resources.push(person.next_location);
                 }
             }
             return new Set(resources);
         }

         function get_available_simple_targets(world) {
             const held_resources = get_held_resources(world);
             var available_targets = {};
             for (const [key, value] of Object.entries(global_simple_targets)) {
                 if (!held_resources.has(key)) {
                     available_targets[key] = value;
                 }
             }
             return available_targets;
         }

         function get_random_key_value(d) {
             const arr = Object.entries(d);
             if (arr.length == 0) {
                 return null;
             }
             return arr[Math.floor(Math.random() * arr.length)];
         }

         function set_starting_state(world, person) {
             const targets = get_available_simple_targets(world);
             const kv = get_random_key_value(targets);
             if (kv === null) {
                 return;
             }
             const [location, make_ani_fn] = kv;
             person.animation = new ContinueWavingAni(person.params, location);
             person.location = location;
         }
         
         function get_graph_neighbors() {
             var neighbors = {};
             for (var [n1, n2] of global_motion_graph.edges) {
                 if (!neighbors.hasOwnProperty(n1)) neighbors[n1] = [];
                 if (!neighbors.hasOwnProperty(n2)) neighbors[n2] = [];
                 neighbors[n1].push(n2);
                 neighbors[n2].push(n1);
             }
             return neighbors;
         }

         function get_path(start_node, end_node) {
             // Get neighbors of each node.
             const neighbors = get_graph_neighbors();

             // DFS the graph from start_node.
             var backtrace = {[start_node]: null};
             var queue = [start_node];
             while (queue.length > 0) {
                 const current = queue.shift();
                 for (const next of neighbors[current]) {
                     if (backtrace.hasOwnProperty(next)) continue;
                     backtrace[next] = current;
                     queue.push(next);
                 }
             }

             // Construct the path by following backtraces from end_node.
             var path = [];
             var node = end_node;
             while (node !== null && node !== undefined) {
                 path.push(node);
                 node = backtrace[node];
             }
             path.reverse();
             return path;
         }

         function lerp(a, b, t) {
             return a + (b - a) * t;
         }

         // Returns {p: [x, y], finished: bool}.
         function get_point_along_path(path, pixels) {
             for (var i = 0; i < path.length - 1; i += 1) {
                 const [x1, y1] = global_motion_graph.nodes[path[i]];
                 const [x2, y2] = global_motion_graph.nodes[path[i+1]];
                 const distance = Math.sqrt((x2 - x1)**2 + (y2 - y1)**2);
                 if (pixels <= distance) {
                     const frac = pixels / distance;
                     const x = lerp(x1, x2, frac);
                     const y = lerp(y1, y2, frac);
                     return {
                         p: [x, y],
                         finished: false,
                     };
                 }
                 pixels -= distance;
             }

             // If we get here, we've finished the path.
             return {
                 p: global_motion_graph.nodes[path[path.length-1]],
                 finished: true,
             };
         }

         function make_person(head_image, arm_color, body_color, bounce_period, arm_period) {
             return {
                 params: {
                     head_image: head_image,
                     scale: 0.25,
                     arm_color: arm_color,
                     body_color: body_color,
                     bounce: {
                         offset_ms: 0,
                         period_ms: bounce_period,
                     },
                     arm: {
                         offset_ms: 0,
                         period_ms: arm_period,
                     },
                     walking_speed_pps: 150,
                 },
                 animation: null,
                 next_action_time: null,
                 location: null,
                 event: null,
                 next_animation: null,
                 next_location: null,
                 next_event: null,
             };
         }

         function get_image_promise([key, url]) {
             return new Promise((resolve, reject) => {
                 const image = new Image();
                 image.src = url;
                 image.onload = () => { resolve({[key]: image}); };
                 image.onerror = () => { reject("Failed to load: " + url); };
             });
         }

         // Returns a promise that resolves to a map of all the images once they are loaded.
         function load_images() {
             const promises = Object.entries(global_image_urls).map(get_image_promise);
             return Promise.all(promises).then((key_value_array) => {
                 // Convert key-value array to dictionary.
                 return Object.assign({}, ...key_value_array);
             });
         }

         function draw_arm(ctx, color, shoulder_x, shoulder_y, radius, length, rotation) {
             ctx.save();
             ctx.fillStyle = color;

             ctx.translate(shoulder_x, shoulder_y);
             ctx.rotate(rotation);

             ctx.beginPath();
             ctx.arc(0, 0, radius, 0, 2 * Math.PI);
             ctx.fill();

             ctx.beginPath();
             ctx.arc(0, length, radius, 0, 2 * Math.PI);
             ctx.fill();

             ctx.fillRect(-radius, 0, 2 * radius, length);

             ctx.restore();
         }

         function eased(time_ms, period_ms) {
             const offset_ms = time_ms % period_ms;
             return 0.5 - Math.cos(offset_ms / period_ms * 2 * Math.PI) / 2.0;
         }

         function get_wave_params_cyclic(person, current_time) {
             return {
                 arm_t: eased(current_time + person.arm.offset_ms, person.arm.period_ms),
                 bounce_t: eased(current_time + person.bounce.offset_ms, person.bounce.period_ms),
             };
         }

         function can_start(current_time, animation_start_time, p) {
             const start_offset = (animation_start_time + p.offset_ms) % p.period_ms;
             const till_end = p.period_ms - start_offset;
             const elapsed = current_time - animation_start_time;
             return elapsed > till_end;
         }

         function can_stop(current_time, animation_start_time, p) {
             const start_iter = Math.floor((animation_start_time + p.offset_ms) / p.period_ms);
             const current_iter = Math.floor((current_time + p.offset_ms) / p.period_ms);
             return current_iter > start_iter;
         }

         function get_wave_params_from_rest(person, current_time, animation_start_time) {
             const can_start_arms = can_start(current_time, animation_start_time, person.arm);
             const can_start_bounce = can_start(current_time, animation_start_time, person.bounce);
             return {
                 arm_t: can_start_arms ?
                        eased(current_time + person.arm.offset_ms, person.arm.period_ms) :
                        0.0,
                 bounce_t: can_start_bounce ?
                           eased(current_time + person.bounce.offset_ms, person.bounce.period_ms) :
                           0.0,
                 done: can_start_arms && can_start_bounce,
             };
         }

         function get_wave_params_to_rest(person, current_time, animation_start_time) {
             const can_stop_arms = can_stop(current_time, animation_start_time, person.arm);
             const can_stop_bounce = can_stop(current_time, animation_start_time, person.bounce);
             return {
                 arm_t: can_stop_arms ?
                        0.0 :
                        eased(current_time + person.arm.offset_ms, person.arm.period_ms),
                 bounce_t: can_stop_bounce ?
                           0.0 :
                           eased(current_time + person.bounce.offset_ms, person.bounce.period_ms),
                 done: can_stop_arms && can_stop_bounce,
             };
         }

         function draw_from_params(params) {
             var canvas = document.getElementById("c");
             var ctx = canvas.getContext("2d");
             ctx.resetTransform();

             const bounce_amount = params.bounce_t * 20;

             const top = 320 + bounce_amount;
             const bottom = 320 + 200;
             const left = 70;

             ctx.scale(params.scale, params.scale);
             ctx.translate(-(50 + left + 170/2), -bottom);
             ctx.translate(params.x / params.scale, params.y / params.scale);

             ctx.fillStyle = params.body_color;
             ctx.fillRect(50 + left, top, 170, (bottom - top));

             ctx.beginPath();
             ctx.arc(50 + left + 170/2, top, 170/2, 0, 2 * Math.PI);
             ctx.fill();

             const arm_offset_x = 10;
             const arm_offset_y = -30;
             draw_arm(ctx, params.arm_color, 50 + left + arm_offset_x, top + arm_offset_y, 20, 100, 2.5 * params.arm_t);
             draw_arm(ctx, params.arm_color, 50 + left + 170 - arm_offset_x, top + arm_offset_y, 20, 100, -2.5 * params.arm_t);

             ctx.drawImage(params.head_image, 30 + left, bounce_amount);
             ctx.resetTransform();
         }

         // The API for an animation is:
         //  * it has a tick() method that draws and returns whether the animation is done.
         //  * it has a request_done() method.
         //  * it has a can_request_done() method that returns true or false.

         class StartWavingAni {
             constructor(person_params, [x, y], layer = "") {
                 this.person_params = person_params;
                 this.x = x;
                 this.y = y;
                 this.layer = layer;
                 this.start_time = null;
             }

             tick(current_time, layer) {
                 if (this.layer !== layer) {
                     return false;
                 }
                 if (this.start_time === null) {
                     this.start_time = current_time;
                 }
                 var params = {
                     x: this.x,
                     y: this.y,
                 };
                 Object.assign(params, this.person_params);
                 Object.assign(params, get_wave_params_from_rest(this.person_params, current_time, this.start_time));
                 draw_from_params(params);
                 return params.done;
             }

             request_done() {}
             
             can_request_done() { return false; }
         }

         class StopWavingAni {
             constructor(person_params, [x, y], layer = "") {
                 this.person_params = person_params;
                 this.x = x;
                 this.y = y;
                 this.layer = layer;
                 this.start_time = null;
             }

             tick(current_time, layer) {
                 if (this.layer !== layer) {
                     return false;
                 }
                 if (this.start_time === null) {
                     this.start_time = current_time;
                 }
                 var params = {
                     x: this.x,
                     y: this.y,
                 };
                 Object.assign(params, this.person_params);
                 Object.assign(params, get_wave_params_to_rest(this.person_params, current_time, this.start_time));
                 draw_from_params(params);
                 return params.done;
             }

             request_done() {}
             
             can_request_done() { return false; }
         }

         class ContinueWavingAni {
             constructor(person_params, node, layer = "", duration = null) {
                 this.person_params = person_params;
                 [this.x, this.y] = global_motion_graph.nodes[node];
                 this.layer = layer;
                 this.start_time = null;
                 this.done = false;
                 this.duration = duration;
             }

             tick(current_time, layer) {
                 if (this.layer !== layer) {
                     return false;
                 }
                 if (this.start_time === null) {
                     this.start_time = current_time;
                 }
                 if (this.duration !== null && current_time - this.start_time >= this.duration) {
                     this.done = true;
                 }
                 var params = {
                     x: this.x,
                     y: this.y,
                 };
                 Object.assign(params, this.person_params);
                 Object.assign(params, get_wave_params_cyclic(this.person_params, current_time, this.start_time));
                 draw_from_params(params);
                 return this.done;
             }

             request_done() {
                 this.done = true;
             }

             can_request_done() { return this.duration === null; }
         }

         class WalkAni {
             constructor(person_params, start_node, end_node, layer = "") {
                 this.person_params = person_params;
                 this.start_node = start_node;
                 this.end_node = end_node;
                 this.layer = layer;
                 this.path = get_path(start_node, end_node);
                 this.start_time = null;
             }

             tick(current_time, layer) {
                 if (this.layer !== layer) {
                     return false;
                 }
                 if (this.start_time === null) {
                     this.start_time = current_time;
                 }
                 const pixels = (current_time - this.start_time) / 1000 * this.person_params.walking_speed_pps;
                 const path_point = get_point_along_path(this.path, pixels);
                 var params = {
                     x: path_point.p[0],
                     y: path_point.p[1],
                 };
                 Object.assign(params, this.person_params);
                 Object.assign(params, get_wave_params_cyclic(this.person_params, current_time, this.start_time));
                 draw_from_params(params);
                 return path_point.finished;
             }

             request_done() {}

             can_request_done() { return false; }
         }

         class WalkToAni {
             constructor(person, end_node, layer = "") {
                 this.person = person;
                 this.end_node = end_node;
                 this.layer = layer;
                 this.child_ani = null;
             }

             tick(current_time, layer) {
                 if (this.child_ani === null) {
                     this.child_ani = new WalkAni(this.person.params, this.person.location, this.end_node, this.layer);
                 }
                 return this.child_ani.tick(current_time, layer);
             }

             request_done() {}

             can_request_done() { return false; }
         }

         class SequentialAni {
             constructor(sequence) {
                 this.sequence = sequence;
                 this.current = 0;
             }

             tick(current_time, layer) {
                 const index = Math.min(this.current, this.sequence.length - 1);
                 const next = this.sequence[index].tick(current_time, layer);
                 if (next && this.current < this.sequence.length) {
                     this.current += 1;
                 }
                 return this.current >= this.sequence.length;
             }

             request_done() {
                 this.sequence.map((a) => { a.request_done(); });
             }

             can_request_done() {
                 const index = Math.min(this.current, this.sequence.length - 1);
                 return this.sequence[index].can_request_done();
             }
         }

         class SimultaneousAni {
             constructor(children) {
                 this.children = children;
             }

             tick(current_time, layer) {
                 var done = true;
                 for (const child of this.children) {
                     done &= child.tick(current_time, layer);
                 }
                 return done;
             }

             request_done() {
                 this.children.map((a) => { a.request_done(); });
             }

             can_request_done() {
                 this.children.every((a) => { return a.can_request_done(); });
             }
         }

         // TODO add resources.
         class Event {
             constructor(world, stages, final_locations) {
                 this.world = world;
                 this.stages = stages;
                 this.final_locations = final_locations;
                 this.current = 0;
                 this.people = {};
             }

             tick(current_time, layer) {
                 const index = Math.min(this.current, this.stages.length - 1);
                 const stage = this.stages[index];

                 // Update people.
                 for (const person in stage) {
                     this.people[person] = this.world.people[person];
                 }

                 // Try to acquire everyone that hasn't been acquired yet.
                 for (const [name, person] of Object.entries(this.people)) {
                     if (person.event !== this && person.next_event !== this) {
                         person.next_event = this;
                     }
                 }

                 // Deal with all the people.
                 var num_done = 0;
                 for (const [name, person] of Object.entries(this.people)) {
                     if (person.event !== this) {
                         continue;
                     }
                     
                     const desired_ani = stage[name];
                     if (desired_ani !== null && person.animation !== desired_ani) {
                         person.animation.request_done();
                         const done = person.animation.tick(current_time, layer);
                         if (done) {
                             person.animation = desired_ani;
                             person.next_action_time = null;
                             person.next_animation = null;
                             person.next_location = null;
                         }
                     } else {
                         const done = person.animation.tick(current_time, layer);
                         if (done) {
                             num_done += 1;
                         }
                     }
                 }

                 // Check if we can move on to the next stage.
                 if (num_done === Object.keys(this.people).length && this.current < this.stages.length) {
                     this.current += 1;
                 }

                 // Check if we are done overall.
                 const done_overall = this.current >= this.stages.length;
                 if (done_overall) {
                     for (const [name, person] of Object.entries(this.people)) {
                         person.event = null;
                     }
                     for (const [name, location] of Object.entries(this.final_locations)) {
                         this.world.people[name].location = location;
                     }
                 }
                 return done_overall;
             }
         }

         function animate(world, current_time, layer) {
             // Animate the people.
             for (var [name, person] of Object.entries(world.people)) {
                 if (person.animation === null) {
                     // Nothing to animate.
                     continue;
                 }

                 if (person.event !== null) {
                     // This person is participating in an event; let the event handle animation.
                     continue;
                 }

                 const done = person.animation.tick(current_time, layer);

                 if (person.next_action_time === null) {
                     // Case 1: not yet in the steady-state for this animation.
                     const in_steady_state = done || person.animation.can_request_done();
                     if (in_steady_state) {
                         person.next_action_time = current_time + 3000; // TODO tweak.
                     }
                 } else if (current_time < person.next_action_time) {
                     // Case 2: waiting for the correct time to start the next animation.
                 } else if (person.next_animation === null && person.next_event === null) {
                     // Case 3: try to pick another animation.
                     const targets = get_available_simple_targets(world);
                     const kv = get_random_key_value(targets);
                     if (kv !== null) {
                         const [location, make_ani_fn] = kv;
                         person.next_location = location;
                         person.next_animation = new SequentialAni([
                             new WalkAni(person.params, person.location, person.next_location),
                             make_ani_fn(person),
                         ]);
                         person.animation.request_done();
                     }
                 } else if (person.next_animation === null && person.next_event !== null) {
                     // Case 4: ready to move on to the event.
                     person.event = person.next_event;
                     person.next_event = null;
                 } else if (!done) {
                     // Case 5: waiting for current animation to be done so we can start the next one.
                 } else {
                     // Case 6: move on to the next animation.
                     person.animation = person.next_animation;
                     person.next_action_time = null;
                     person.location = person.next_location;
                     person.next_animation = null;
                     person.next_location = null;
                 }
             }

             // Animate the currently-active event.
             if (world.event !== null) {
                 const done = world.event.tick(current_time, layer);
                 if (done) {
                     world.event = null;
                     world.last_event_finish_time = current_time;
                 }
             }
         }
         
         function set_up_animation_loop(world) {
             function tick() {
                 const current_time = new Date().getTime();

                 // Clear.
                 var canvas = document.getElementById("c");
                 var ctx = canvas.getContext("2d");
                 ctx.resetTransform();
                 ctx.clearRect(0, 0, canvas.width, canvas.height);

                 // Draw house.
                 ctx.scale(0.25, 0.25);
                 ctx.translate(0, -500);
                 ctx.drawImage(world.images.house, 0, 0);

                 // Animate behind_table layer.
                 animate(world, current_time, "behind_table");
                 
                 // Draw table.
                 ctx.resetTransform();
                 ctx.scale(0.25, 0.25);
                 ctx.translate(0, -500);
                 ctx.drawImage(world.images.table, 0, 0);
                 ctx.resetTransform();

                 // Animate default layer.
                 animate(world, current_time, /*layer=*/"");

                 // Maybe set up a new event.
                 if (world.event === null && current_time - world.last_event_finish_time > 15000) {
                     world.event = sample_event(world);
                     console.log("installed event!");
                 }

                 window.requestAnimationFrame(tick);
             }
             window.requestAnimationFrame(tick);
         }

         // An event has:
         //  * the set of resources held
         //  * a sequence of stages, each of which has:
         //    * the set of people involved
         //    * an animation to run

         function sample_event_old(world) {
             return {
                 ani: new SequentialAni([
                     new SimultaneousAni([
                         new SequentialAni([
                             new WalkAni(world.people.steve.params, "gym", "kitchen_chair_1"),
                             new WalkAni(world.people.steve.params, "kitchen_chair_1", "kitchen_chair_1_seated", "behind_table"),
                             new ContinueWavingAni(world.people.steve.params, "kitchen_chair_1_seated", "behind_table", /*duration=*/0),
                         ]),
                         new SequentialAni([
                             new WalkAni(world.people.david.params, "living_chair_1", "kitchen_chair_2"),
                             new WalkAni(world.people.david.params, "kitchen_chair_2", "kitchen_chair_2_seated", "behind_table"),
                             new ContinueWavingAni(world.people.david.params, "kitchen_chair_2_seated", "behind_table", /*duration=*/0),
                         ]),
                         new SequentialAni([
                             new WalkAni(world.people.carlos.params, "desk_1", "kitchen_chair_3"),
                             new WalkAni(world.people.carlos.params, "kitchen_chair_3", "kitchen_chair_3_seated", "behind_table"),
                             new ContinueWavingAni(world.people.carlos.params, "kitchen_chair_3_seated", "behind_table", /*duration=*/0),
                         ]),
                         new SequentialAni([
                             new WalkAni(world.people.sandro.params, "bed_2", "kitchen_chair_4"),
                             new WalkAni(world.people.sandro.params, "kitchen_chair_4", "kitchen_chair_4_seated", "behind_table"),
                             new ContinueWavingAni(world.people.sandro.params, "kitchen_chair_4_seated", "behind_table", /*duration=*/0),
                         ]),
                     ]),
                     new SimultaneousAni([
                         new ContinueWavingAni(world.people.steve.params, "kitchen_chair_1_seated", "behind_table", /*duration=*/3000),
                         new ContinueWavingAni(world.people.david.params, "kitchen_chair_2_seated", "behind_table", /*duration=*/3000),
                         new ContinueWavingAni(world.people.carlos.params, "kitchen_chair_3_seated", "behind_table", /*duration=*/3000),
                         new ContinueWavingAni(world.people.sandro.params, "kitchen_chair_4_seated", "behind_table", /*duration=*/3000),
                     ]),
                     new SimultaneousAni([
                         new SequentialAni([
                             new WalkAni(world.people.steve.params, "kitchen_chair_1_seated", "kitchen_chair_1", "behind_table"),
                             new WalkAni(world.people.steve.params, "kitchen_chair_1", "gym"),
                         ]),
                         new SequentialAni([
                             new WalkAni(world.people.david.params, "kitchen_chair_2_seated", "kitchen_chair_2", "behind_table"),
                             new WalkAni(world.people.david.params, "kitchen_chair_2", "living_chair_1"),
                         ]),
                         new SequentialAni([
                             new WalkAni(world.people.carlos.params, "kitchen_chair_3_seated", "kitchen_chair_3", "behind_table"),
                             new WalkAni(world.people.carlos.params, "kitchen_chair_3", "desk_1"),
                         ]),
                         new SequentialAni([
                             new WalkAni(world.people.sandro.params, "kitchen_chair_4_seated", "kitchen_chair_4", "behind_table"),
                             new WalkAni(world.people.sandro.params, "kitchen_chair_4", "bed_2"),
                         ]),
                     ]),
                 ]),
             };
         }

         function sample_event(world) {
             const steve = world.people.steve;
             const david = world.people.david;
             const carlos = world.people.carlos;
             const sandro = world.people.sandro;
             return new Event(world, [
                 {
                     steve: new SequentialAni([
                         new WalkToAni(steve, "kitchen_chair_1"),
                         new WalkAni(steve.params, "kitchen_chair_1", "kitchen_chair_1_seated", "behind_table"),
                         new ContinueWavingAni(steve.params, "kitchen_chair_1_seated", "behind_table", /*duration=*/0),
                     ]),
                     david: new SequentialAni([
                         new WalkToAni(david, "kitchen_chair_2"),
                         new WalkAni(david.params, "kitchen_chair_2", "kitchen_chair_2_seated", "behind_table"),
                         new ContinueWavingAni(david.params, "kitchen_chair_2_seated", "behind_table", /*duration=*/0),
                     ]),
                     carlos: new SequentialAni([
                         new WalkToAni(carlos, "kitchen_chair_3"),
                         new WalkAni(carlos.params, "kitchen_chair_3", "kitchen_chair_3_seated", "behind_table"),
                         new ContinueWavingAni(carlos.params, "kitchen_chair_3_seated", "behind_table", /*duration=*/0),
                     ]),
                     sandro: new SequentialAni([
                         new WalkToAni(sandro, "kitchen_chair_4"),
                         new WalkAni(sandro.params, "kitchen_chair_4", "kitchen_chair_4_seated", "behind_table"),
                         new ContinueWavingAni(sandro.params, "kitchen_chair_4_seated", "behind_table", /*duration=*/0),
                     ]),
                 },
                 {
                     steve: new ContinueWavingAni(steve.params, "kitchen_chair_1_seated", "behind_table", /*duration=*/3000),
                     david: new ContinueWavingAni(david.params, "kitchen_chair_2_seated", "behind_table", /*duration=*/3000),
                     carlos: new ContinueWavingAni(carlos.params, "kitchen_chair_3_seated", "behind_table", /*duration=*/3000),
                     sandro: new ContinueWavingAni(sandro.params, "kitchen_chair_4_seated", "behind_table", /*duration=*/3000),
                 },
                 {
                     steve: new SequentialAni([
                         new WalkAni(steve.params, "kitchen_chair_1_seated", "kitchen_chair_1", "behind_table"),
                         new WalkAni(steve.params, "kitchen_chair_1", "gym"),
                     ]),
                     david: new SequentialAni([
                         new WalkAni(david.params, "kitchen_chair_2_seated", "kitchen_chair_2", "behind_table"),
                         new WalkAni(david.params, "kitchen_chair_2", "living_chair_1"),
                     ]),
                     carlos: new SequentialAni([
                         new WalkAni(carlos.params, "kitchen_chair_3_seated", "kitchen_chair_3", "behind_table"),
                         new WalkAni(carlos.params, "kitchen_chair_3", "desk_1"),
                     ]),
                     sandro: new SequentialAni([
                         new WalkAni(sandro.params, "kitchen_chair_4_seated", "kitchen_chair_4", "behind_table"),
                         new WalkAni(sandro.params, "kitchen_chair_4", "bed_2"),
                     ]),
                 }
             ], {
                 steve: "gym",
                 david: "living_chair_1",
                 carlos: "desk_1",
                 sandro: "bed_2",
             });
         }
         
         function main() {
             load_images().then((images) => {
                 const world = {
                     images: images,
                     people: {
                         steve: make_person(
                             images.steve,
                             /*arm_color=*/"blue",
                             /*body_color=*/"green",
                             /*bounce_period=*/900,
                             /*arm_period=*/2200
                         ),
                         david: make_person(
                             images.david,
                             /*arm_color=*/"blue",
                             /*body_color=*/"green",
                             /*bounce_period=*/1100,
                             /*arm_period=*/2000
                         ),
                         carlos: make_person(
                             images.carlos,
                             /*arm_color=*/"blue",
                             /*body_color=*/"green",
                             /*bounce_period=*/800,
                             /*arm_period=*/1800
                         ),
                         sandro: make_person(
                             images.sandro,
                             /*arm_color=*/"blue",
                             /*body_color=*/"green",
                             /*bounce_period=*/1000,
                             /*arm_period=*/1300
                         ),
                     },
                     event: null,
                     last_event_finish_time: new Date().getTime(),
                 };
                 // world.event = sample_event(world);
                 set_starting_state(world, world.people.steve);
                 set_starting_state(world, world.people.david);
                 set_starting_state(world, world.people.carlos);
                 set_starting_state(world, world.people.sandro);
                 /* world.people.steve.animation = new SequentialAni([
                  *     new StartWavingAni(world.people.steve.params, global_motion_graph.nodes.living_chair_2),
                  *     //new ContinueWavingAni(world.people.steve.params, global_motion_graph.nodes.living_chair_2),
                  *     new WalkAni(world.people.steve.params, "living_chair_2", "gym"),
                  *     new StopWavingAni(world.people.steve.params, global_motion_graph.nodes.gym),
                  * ]);*/
                 set_up_animation_loop(world);
             });
         }

         window.onload = main;
         console.log("test");
        </script>
    </head>
    <body>
        <canvas id="c" width="2300px" height="1100px"> </canvas>
    </body>
</html>
